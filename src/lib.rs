#![doc = "Peripheral access API for XMC4500 microcontrollers (generated using svd2rust v0.33.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 6;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn SCU_0();
    fn ERU0_0();
    fn ERU0_1();
    fn ERU0_2();
    fn ERU0_3();
    fn ERU1_0();
    fn ERU1_1();
    fn ERU1_2();
    fn ERU1_3();
    fn PMU0_0();
    fn VADC0_C0_0();
    fn VADC0_C0_1();
    fn VADC0_C0_2();
    fn VADC0_C0_3();
    fn VADC0_G0_0();
    fn VADC0_G0_1();
    fn VADC0_G0_2();
    fn VADC0_G0_3();
    fn VADC0_G1_0();
    fn VADC0_G1_1();
    fn VADC0_G1_2();
    fn VADC0_G1_3();
    fn VADC0_G2_0();
    fn VADC0_G2_1();
    fn VADC0_G2_2();
    fn VADC0_G2_3();
    fn VADC0_G3_0();
    fn VADC0_G3_1();
    fn VADC0_G3_2();
    fn VADC0_G3_3();
    fn DSD0_M_0();
    fn DSD0_M_1();
    fn DSD0_M_2();
    fn DSD0_M_3();
    fn DSD0_A_4();
    fn DSD0_A_5();
    fn DSD0_A_6();
    fn DSD0_A_7();
    fn DAC0_0();
    fn DAC0_1();
    fn CCU40_0();
    fn CCU40_1();
    fn CCU40_2();
    fn CCU40_3();
    fn CCU41_0();
    fn CCU41_1();
    fn CCU41_2();
    fn CCU41_3();
    fn CCU42_0();
    fn CCU42_1();
    fn CCU42_2();
    fn CCU42_3();
    fn CCU43_0();
    fn CCU43_1();
    fn CCU43_2();
    fn CCU43_3();
    fn CCU80_0();
    fn CCU80_1();
    fn CCU80_2();
    fn CCU80_3();
    fn CCU81_0();
    fn CCU81_1();
    fn CCU81_2();
    fn CCU81_3();
    fn POSIF0_0();
    fn POSIF0_1();
    fn POSIF1_0();
    fn POSIF1_1();
    fn CAN0_0();
    fn CAN0_1();
    fn CAN0_2();
    fn CAN0_3();
    fn CAN0_4();
    fn CAN0_5();
    fn CAN0_6();
    fn CAN0_7();
    fn USIC0_0();
    fn USIC0_1();
    fn USIC0_2();
    fn USIC0_3();
    fn USIC0_4();
    fn USIC0_5();
    fn USIC1_0();
    fn USIC1_1();
    fn USIC1_2();
    fn USIC1_3();
    fn USIC1_4();
    fn USIC1_5();
    fn USIC2_0();
    fn USIC2_1();
    fn USIC2_2();
    fn USIC2_3();
    fn USIC2_4();
    fn USIC2_5();
    fn LEDTS0_0();
    fn FCE0_0();
    fn GPDMA0_0();
    fn SDMMC0_0();
    fn USB0_0();
    fn ETH0_0();
    fn GPDMA1_0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 111] = [
    Vector { _handler: SCU_0 },
    Vector { _handler: ERU0_0 },
    Vector { _handler: ERU0_1 },
    Vector { _handler: ERU0_2 },
    Vector { _handler: ERU0_3 },
    Vector { _handler: ERU1_0 },
    Vector { _handler: ERU1_1 },
    Vector { _handler: ERU1_2 },
    Vector { _handler: ERU1_3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PMU0_0 },
    Vector { _reserved: 0 },
    Vector { _handler: VADC0_C0_0 },
    Vector { _handler: VADC0_C0_1 },
    Vector { _handler: VADC0_C0_2 },
    Vector { _handler: VADC0_C0_3 },
    Vector { _handler: VADC0_G0_0 },
    Vector { _handler: VADC0_G0_1 },
    Vector { _handler: VADC0_G0_2 },
    Vector { _handler: VADC0_G0_3 },
    Vector { _handler: VADC0_G1_0 },
    Vector { _handler: VADC0_G1_1 },
    Vector { _handler: VADC0_G1_2 },
    Vector { _handler: VADC0_G1_3 },
    Vector { _handler: VADC0_G2_0 },
    Vector { _handler: VADC0_G2_1 },
    Vector { _handler: VADC0_G2_2 },
    Vector { _handler: VADC0_G2_3 },
    Vector { _handler: VADC0_G3_0 },
    Vector { _handler: VADC0_G3_1 },
    Vector { _handler: VADC0_G3_2 },
    Vector { _handler: VADC0_G3_3 },
    Vector { _handler: DSD0_M_0 },
    Vector { _handler: DSD0_M_1 },
    Vector { _handler: DSD0_M_2 },
    Vector { _handler: DSD0_M_3 },
    Vector { _handler: DSD0_A_4 },
    Vector { _handler: DSD0_A_5 },
    Vector { _handler: DSD0_A_6 },
    Vector { _handler: DSD0_A_7 },
    Vector { _handler: DAC0_0 },
    Vector { _handler: DAC0_1 },
    Vector { _handler: CCU40_0 },
    Vector { _handler: CCU40_1 },
    Vector { _handler: CCU40_2 },
    Vector { _handler: CCU40_3 },
    Vector { _handler: CCU41_0 },
    Vector { _handler: CCU41_1 },
    Vector { _handler: CCU41_2 },
    Vector { _handler: CCU41_3 },
    Vector { _handler: CCU42_0 },
    Vector { _handler: CCU42_1 },
    Vector { _handler: CCU42_2 },
    Vector { _handler: CCU42_3 },
    Vector { _handler: CCU43_0 },
    Vector { _handler: CCU43_1 },
    Vector { _handler: CCU43_2 },
    Vector { _handler: CCU43_3 },
    Vector { _handler: CCU80_0 },
    Vector { _handler: CCU80_1 },
    Vector { _handler: CCU80_2 },
    Vector { _handler: CCU80_3 },
    Vector { _handler: CCU81_0 },
    Vector { _handler: CCU81_1 },
    Vector { _handler: CCU81_2 },
    Vector { _handler: CCU81_3 },
    Vector { _handler: POSIF0_0 },
    Vector { _handler: POSIF0_1 },
    Vector { _handler: POSIF1_0 },
    Vector { _handler: POSIF1_1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CAN0_0 },
    Vector { _handler: CAN0_1 },
    Vector { _handler: CAN0_2 },
    Vector { _handler: CAN0_3 },
    Vector { _handler: CAN0_4 },
    Vector { _handler: CAN0_5 },
    Vector { _handler: CAN0_6 },
    Vector { _handler: CAN0_7 },
    Vector { _handler: USIC0_0 },
    Vector { _handler: USIC0_1 },
    Vector { _handler: USIC0_2 },
    Vector { _handler: USIC0_3 },
    Vector { _handler: USIC0_4 },
    Vector { _handler: USIC0_5 },
    Vector { _handler: USIC1_0 },
    Vector { _handler: USIC1_1 },
    Vector { _handler: USIC1_2 },
    Vector { _handler: USIC1_3 },
    Vector { _handler: USIC1_4 },
    Vector { _handler: USIC1_5 },
    Vector { _handler: USIC2_0 },
    Vector { _handler: USIC2_1 },
    Vector { _handler: USIC2_2 },
    Vector { _handler: USIC2_3 },
    Vector { _handler: USIC2_4 },
    Vector { _handler: USIC2_5 },
    Vector { _handler: LEDTS0_0 },
    Vector { _reserved: 0 },
    Vector { _handler: FCE0_0 },
    Vector { _handler: GPDMA0_0 },
    Vector { _handler: SDMMC0_0 },
    Vector { _handler: USB0_0 },
    Vector { _handler: ETH0_0 },
    Vector { _reserved: 0 },
    Vector { _handler: GPDMA1_0 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - System Control"]
    SCU_0 = 0,
    #[doc = "1 - External Request Unit 0"]
    ERU0_0 = 1,
    #[doc = "2 - External Request Unit 0"]
    ERU0_1 = 2,
    #[doc = "3 - External Request Unit 0"]
    ERU0_2 = 3,
    #[doc = "4 - External Request Unit 0"]
    ERU0_3 = 4,
    #[doc = "5 - External Request Unit 1"]
    ERU1_0 = 5,
    #[doc = "6 - External Request Unit 1"]
    ERU1_1 = 6,
    #[doc = "7 - External Request Unit 1"]
    ERU1_2 = 7,
    #[doc = "8 - External Request Unit 1"]
    ERU1_3 = 8,
    #[doc = "12 - Program Management Unit"]
    PMU0_0 = 12,
    #[doc = "14 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_0 = 14,
    #[doc = "15 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_1 = 15,
    #[doc = "16 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_2 = 16,
    #[doc = "17 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_3 = 17,
    #[doc = "18 - Analog to Digital Converter Group 0"]
    VADC0_G0_0 = 18,
    #[doc = "19 - Analog to Digital Converter Group 0"]
    VADC0_G0_1 = 19,
    #[doc = "20 - Analog to Digital Converter Group 0"]
    VADC0_G0_2 = 20,
    #[doc = "21 - Analog to Digital Converter Group 0"]
    VADC0_G0_3 = 21,
    #[doc = "22 - Analog to Digital Converter Group 1"]
    VADC0_G1_0 = 22,
    #[doc = "23 - Analog to Digital Converter Group 1"]
    VADC0_G1_1 = 23,
    #[doc = "24 - Analog to Digital Converter Group 1"]
    VADC0_G1_2 = 24,
    #[doc = "25 - Analog to Digital Converter Group 1"]
    VADC0_G1_3 = 25,
    #[doc = "26 - Analog to Digital Converter Group 2"]
    VADC0_G2_0 = 26,
    #[doc = "27 - Analog to Digital Converter Group 2"]
    VADC0_G2_1 = 27,
    #[doc = "28 - Analog to Digital Converter Group 2"]
    VADC0_G2_2 = 28,
    #[doc = "29 - Analog to Digital Converter Group 2"]
    VADC0_G2_3 = 29,
    #[doc = "30 - Analog to Digital Converter Group 3"]
    VADC0_G3_0 = 30,
    #[doc = "31 - Analog to Digital Converter Group 3"]
    VADC0_G3_1 = 31,
    #[doc = "32 - Analog to Digital Converter Group 3"]
    VADC0_G3_2 = 32,
    #[doc = "33 - Analog to Digital Converter Group 3"]
    VADC0_G3_3 = 33,
    #[doc = "34 - Delta Sigma Demodulator Main"]
    DSD0_M_0 = 34,
    #[doc = "35 - Delta Sigma Demodulator Main"]
    DSD0_M_1 = 35,
    #[doc = "36 - Delta Sigma Demodulator Main"]
    DSD0_M_2 = 36,
    #[doc = "37 - Delta Sigma Demodulator Main"]
    DSD0_M_3 = 37,
    #[doc = "38 - Delta Sigma Demodulator Auxiliary"]
    DSD0_A_4 = 38,
    #[doc = "39 - Delta Sigma Demodulator Auxiliary"]
    DSD0_A_5 = 39,
    #[doc = "40 - Delta Sigma Demodulator Auxiliary"]
    DSD0_A_6 = 40,
    #[doc = "41 - Delta Sigma Demodulator Auxiliary"]
    DSD0_A_7 = 41,
    #[doc = "42 - Digital to Analog Converter"]
    DAC0_0 = 42,
    #[doc = "43 - Digital to Analog Converter"]
    DAC0_1 = 43,
    #[doc = "44 - Capture Compare Unit 4 (Module 0)"]
    CCU40_0 = 44,
    #[doc = "45 - Capture Compare Unit 4 (Module 0)"]
    CCU40_1 = 45,
    #[doc = "46 - Capture Compare Unit 4 (Module 0)"]
    CCU40_2 = 46,
    #[doc = "47 - Capture Compare Unit 4 (Module 0)"]
    CCU40_3 = 47,
    #[doc = "48 - Capture Compare Unit 4 (Module 1)"]
    CCU41_0 = 48,
    #[doc = "49 - Capture Compare Unit 4 (Module 1)"]
    CCU41_1 = 49,
    #[doc = "50 - Capture Compare Unit 4 (Module 1)"]
    CCU41_2 = 50,
    #[doc = "51 - Capture Compare Unit 4 (Module 1)"]
    CCU41_3 = 51,
    #[doc = "52 - Capture Compare Unit 4 (Module 2)"]
    CCU42_0 = 52,
    #[doc = "53 - Capture Compare Unit 4 (Module 2)"]
    CCU42_1 = 53,
    #[doc = "54 - Capture Compare Unit 4 (Module 2)"]
    CCU42_2 = 54,
    #[doc = "55 - Capture Compare Unit 4 (Module 2)"]
    CCU42_3 = 55,
    #[doc = "56 - Capture Compare Unit 4 (Module 3)"]
    CCU43_0 = 56,
    #[doc = "57 - Capture Compare Unit 4 (Module 3)"]
    CCU43_1 = 57,
    #[doc = "58 - Capture Compare Unit 4 (Module 3)"]
    CCU43_2 = 58,
    #[doc = "59 - Capture Compare Unit 4 (Module 3)"]
    CCU43_3 = 59,
    #[doc = "60 - Capture Compare Unit 8 (Module 0)"]
    CCU80_0 = 60,
    #[doc = "61 - Capture Compare Unit 8 (Module 0)"]
    CCU80_1 = 61,
    #[doc = "62 - Capture Compare Unit 8 (Module 0)"]
    CCU80_2 = 62,
    #[doc = "63 - Capture Compare Unit 8 (Module 0)"]
    CCU80_3 = 63,
    #[doc = "64 - Capture Compare Unit 8 (Module 1)"]
    CCU81_0 = 64,
    #[doc = "65 - Capture Compare Unit 8 (Module 1)"]
    CCU81_1 = 65,
    #[doc = "66 - Capture Compare Unit 8 (Module 1)"]
    CCU81_2 = 66,
    #[doc = "67 - Capture Compare Unit 8 (Module 1)"]
    CCU81_3 = 67,
    #[doc = "68 - Position Interface (Module 0)"]
    POSIF0_0 = 68,
    #[doc = "69 - Position Interface (Module 0)"]
    POSIF0_1 = 69,
    #[doc = "70 - Position Interface (Module 1)"]
    POSIF1_0 = 70,
    #[doc = "71 - Position Interface (Module 1)"]
    POSIF1_1 = 71,
    #[doc = "76 - MultiCAN"]
    CAN0_0 = 76,
    #[doc = "77 - MultiCAN"]
    CAN0_1 = 77,
    #[doc = "78 - MultiCAN"]
    CAN0_2 = 78,
    #[doc = "79 - MultiCAN"]
    CAN0_3 = 79,
    #[doc = "80 - MultiCAN"]
    CAN0_4 = 80,
    #[doc = "81 - MultiCAN"]
    CAN0_5 = 81,
    #[doc = "82 - MultiCAN"]
    CAN0_6 = 82,
    #[doc = "83 - MultiCAN"]
    CAN0_7 = 83,
    #[doc = "84 - Universal Serial Interface Channel (Module 0)"]
    USIC0_0 = 84,
    #[doc = "85 - Universal Serial Interface Channel (Module 0)"]
    USIC0_1 = 85,
    #[doc = "86 - Universal Serial Interface Channel (Module 0)"]
    USIC0_2 = 86,
    #[doc = "87 - Universal Serial Interface Channel (Module 0)"]
    USIC0_3 = 87,
    #[doc = "88 - Universal Serial Interface Channel (Module 0)"]
    USIC0_4 = 88,
    #[doc = "89 - Universal Serial Interface Channel (Module 0)"]
    USIC0_5 = 89,
    #[doc = "90 - Universal Serial Interface Channel (Module 1)"]
    USIC1_0 = 90,
    #[doc = "91 - Universal Serial Interface Channel (Module 1)"]
    USIC1_1 = 91,
    #[doc = "92 - Universal Serial Interface Channel (Module 1)"]
    USIC1_2 = 92,
    #[doc = "93 - Universal Serial Interface Channel (Module 1)"]
    USIC1_3 = 93,
    #[doc = "94 - Universal Serial Interface Channel (Module 1)"]
    USIC1_4 = 94,
    #[doc = "95 - Universal Serial Interface Channel (Module 1)"]
    USIC1_5 = 95,
    #[doc = "96 - Universal Serial Interface Channel (Module 2)"]
    USIC2_0 = 96,
    #[doc = "97 - Universal Serial Interface Channel (Module 2)"]
    USIC2_1 = 97,
    #[doc = "98 - Universal Serial Interface Channel (Module 2)"]
    USIC2_2 = 98,
    #[doc = "99 - Universal Serial Interface Channel (Module 2)"]
    USIC2_3 = 99,
    #[doc = "100 - Universal Serial Interface Channel (Module 2)"]
    USIC2_4 = 100,
    #[doc = "101 - Universal Serial Interface Channel (Module 2)"]
    USIC2_5 = 101,
    #[doc = "102 - LED and Touch Sense Control Unit (Module 0)"]
    LEDTS0_0 = 102,
    #[doc = "104 - Flexible CRC Engine"]
    FCE0_0 = 104,
    #[doc = "105 - General Purpose DMA Unit 0"]
    GPDMA0_0 = 105,
    #[doc = "106 - Multi Media Card Interface"]
    SDMMC0_0 = 106,
    #[doc = "107 - Universal Serial Bus (Module 0)"]
    USB0_0 = 107,
    #[doc = "108 - Ethernet (Module 0)"]
    ETH0_0 = 108,
    #[doc = "110 - General Purpose DMA Unit 1"]
    GPDMA1_0 = 110,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Cortex-M4 Private Peripheral Block"]
pub struct Ppb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ppb {}
impl Ppb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ppb::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ppb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ppb {
    type Target = ppb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ppb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ppb").finish()
    }
}
#[doc = "Cortex-M4 Private Peripheral Block"]
pub mod ppb;
#[doc = "DMA Line Router"]
pub struct Dlr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dlr {}
impl Dlr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dlr::RegisterBlock = 0x5000_4900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dlr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Dlr {
    type Target = dlr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dlr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dlr").finish()
    }
}
#[doc = "DMA Line Router"]
pub mod dlr;
#[doc = "Event Request Unit 0"]
pub struct Eru0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eru0 {}
impl Eru0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eru0::RegisterBlock = 0x5000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eru0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eru0 {
    type Target = eru0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eru0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eru0").finish()
    }
}
#[doc = "Event Request Unit 0"]
pub mod eru0;
#[doc = "Event Request Unit 1"]
pub struct Eru1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eru1 {}
impl Eru1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eru0::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eru0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eru1 {
    type Target = eru0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eru1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eru1").finish()
    }
}
#[doc = "Event Request Unit 1"]
pub use self::eru0 as eru1;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0 {}
impl Gpdma0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0::RegisterBlock = 0x5001_42c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0 {
    type Target = gpdma0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch0 {}
impl Gpdma0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch0::RegisterBlock = 0x5001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch0 {
    type Target = gpdma0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch0").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0_ch0;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch1 {}
impl Gpdma0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch0::RegisterBlock = 0x5001_4058 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch1 {
    type Target = gpdma0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch1").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch0 as gpdma0_ch1;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch2 {}
impl Gpdma0Ch2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_40b0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch2 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch2").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0_ch2;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch3 {}
impl Gpdma0Ch3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4108 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch3 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch3").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch3;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch4 {}
impl Gpdma0Ch4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4160 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch4 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch4").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch4;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch5 {}
impl Gpdma0Ch5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_41b8 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch5 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch5").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch5;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch6 {}
impl Gpdma0Ch6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4210 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch6 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch6").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch6;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch7 {}
impl Gpdma0Ch7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4268 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch7 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch7").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch7;
#[doc = "General Purpose DMA Unit 1"]
pub struct Gpdma1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma1 {}
impl Gpdma1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma1::RegisterBlock = 0x5001_82c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma1 {
    type Target = gpdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma1").finish()
    }
}
#[doc = "General Purpose DMA Unit 1"]
pub mod gpdma1;
#[doc = "General Purpose DMA Unit 1"]
pub struct Gpdma1Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma1Ch0 {}
impl Gpdma1Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma1_ch0::RegisterBlock = 0x5001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma1_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma1Ch0 {
    type Target = gpdma1_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma1Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma1Ch0").finish()
    }
}
#[doc = "General Purpose DMA Unit 1"]
pub mod gpdma1_ch0;
#[doc = "General Purpose DMA Unit 1"]
pub struct Gpdma1Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma1Ch1 {}
impl Gpdma1Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma1_ch0::RegisterBlock = 0x5001_8058 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma1_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma1Ch1 {
    type Target = gpdma1_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma1Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma1Ch1").finish()
    }
}
#[doc = "General Purpose DMA Unit 1"]
pub use self::gpdma1_ch0 as gpdma1_ch1;
#[doc = "General Purpose DMA Unit 1"]
pub struct Gpdma1Ch2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma1Ch2 {}
impl Gpdma1Ch2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma1_ch0::RegisterBlock = 0x5001_80b0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma1_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma1Ch2 {
    type Target = gpdma1_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma1Ch2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma1Ch2").finish()
    }
}
#[doc = "General Purpose DMA Unit 1"]
pub use self::gpdma1_ch0 as gpdma1_ch2;
#[doc = "General Purpose DMA Unit 1"]
pub struct Gpdma1Ch3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma1Ch3 {}
impl Gpdma1Ch3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma1_ch0::RegisterBlock = 0x5001_8108 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma1_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma1Ch3 {
    type Target = gpdma1_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma1Ch3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma1Ch3").finish()
    }
}
#[doc = "General Purpose DMA Unit 1"]
pub use self::gpdma1_ch0 as gpdma1_ch3;
#[doc = "Flexible CRC Engine"]
pub struct Fce {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fce {}
impl Fce {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce::RegisterBlock = 0x5002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Fce {
    type Target = fce::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fce {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fce").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub mod fce;
#[doc = "Flexible CRC Engine"]
pub struct FceKe0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe0 {}
impl FceKe0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe0 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe0").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub mod fce_ke0;
#[doc = "Flexible CRC Engine"]
pub struct FceKe1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe1 {}
impl FceKe1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe1 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe1").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke1;
#[doc = "Flexible CRC Engine"]
pub struct FceKe2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe2 {}
impl FceKe2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe2 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe2").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke2;
#[doc = "Flexible CRC Engine"]
pub struct FceKe3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe3 {}
impl FceKe3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe3 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe3").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke3;
#[doc = "Peripheral Bridge AHB 0"]
pub struct Pba0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pba0 {}
impl Pba0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pba0::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pba0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pba0 {
    type Target = pba0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pba0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pba0").finish()
    }
}
#[doc = "Peripheral Bridge AHB 0"]
pub mod pba0;
#[doc = "Peripheral Bridge AHB 1"]
pub struct Pba1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pba1 {}
impl Pba1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pba0::RegisterBlock = 0x4800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pba0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pba1 {
    type Target = pba0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pba1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pba1").finish()
    }
}
#[doc = "Peripheral Bridge AHB 1"]
pub use self::pba0 as pba1;
#[doc = "Flash Memory Controller"]
pub struct Flash0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flash0 {}
impl Flash0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash0::RegisterBlock = 0x5800_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Flash0 {
    type Target = flash0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flash0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flash0").finish()
    }
}
#[doc = "Flash Memory Controller"]
pub mod flash0;
#[doc = "Prefetch Unit"]
pub struct Pref {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pref {}
impl Pref {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref::RegisterBlock = 0x5800_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pref {
    type Target = pref::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pref {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pref").finish()
    }
}
#[doc = "Prefetch Unit"]
pub mod pref;
#[doc = "Program Management Unit"]
pub struct Pmu0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmu0 {}
impl Pmu0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmu0::RegisterBlock = 0x5800_0508 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pmu0 {
    type Target = pmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmu0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmu0").finish()
    }
}
#[doc = "Program Management Unit"]
pub mod pmu0;
#[doc = "Watch Dog Timer"]
pub struct Wdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt {}
impl Wdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Watch Dog Timer"]
pub mod wdt;
#[doc = "Real Time Clock"]
pub struct Rtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc {}
impl Rtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x5000_4a00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "Real Time Clock"]
pub mod rtc;
#[doc = "System Control Unit"]
pub struct ScuClk {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuClk {}
impl ScuClk {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_clk::RegisterBlock = 0x5000_4600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_clk::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuClk {
    type Target = scu_clk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuClk {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuClk").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_clk;
#[doc = "System Control Unit"]
pub struct ScuOsc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuOsc {}
impl ScuOsc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_osc::RegisterBlock = 0x5000_4700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_osc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuOsc {
    type Target = scu_osc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuOsc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuOsc").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_osc;
#[doc = "System Control Unit"]
pub struct ScuPll {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuPll {}
impl ScuPll {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_pll::RegisterBlock = 0x5000_4710 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_pll::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuPll {
    type Target = scu_pll::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuPll {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuPll").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_pll;
#[doc = "System Control Unit"]
pub struct ScuGeneral {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuGeneral {}
impl ScuGeneral {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_general::RegisterBlock = 0x5000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_general::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuGeneral {
    type Target = scu_general::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuGeneral {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuGeneral").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_general;
#[doc = "System Control Unit"]
pub struct ScuInterrupt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuInterrupt {}
impl ScuInterrupt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_interrupt::RegisterBlock = 0x5000_4074 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_interrupt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuInterrupt {
    type Target = scu_interrupt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuInterrupt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuInterrupt").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_interrupt;
#[doc = "System Control Unit"]
pub struct ScuParity {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuParity {}
impl ScuParity {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_parity::RegisterBlock = 0x5000_413c as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_parity::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuParity {
    type Target = scu_parity::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuParity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuParity").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_parity;
#[doc = "System Control Unit"]
pub struct ScuTrap {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuTrap {}
impl ScuTrap {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_trap::RegisterBlock = 0x5000_4160 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_trap::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuTrap {
    type Target = scu_trap::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuTrap {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuTrap").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_trap;
#[doc = "System Control Unit"]
pub struct ScuHibernate {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuHibernate {}
impl ScuHibernate {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_hibernate::RegisterBlock = 0x5000_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_hibernate::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuHibernate {
    type Target = scu_hibernate::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuHibernate {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuHibernate").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_hibernate;
#[doc = "System Control Unit"]
pub struct ScuPower {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuPower {}
impl ScuPower {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_power::RegisterBlock = 0x5000_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_power::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuPower {
    type Target = scu_power::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuPower {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuPower").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_power;
#[doc = "System Control Unit"]
pub struct ScuReset {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuReset {}
impl ScuReset {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_reset::RegisterBlock = 0x5000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_reset::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuReset {
    type Target = scu_reset::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuReset {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuReset").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_reset;
#[doc = "LED and Touch Sense Unit 0"]
pub struct Ledts0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ledts0 {}
impl Ledts0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ledts0::RegisterBlock = 0x4801_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ledts0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ledts0 {
    type Target = ledts0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ledts0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ledts0").finish()
    }
}
#[doc = "LED and Touch Sense Unit 0"]
pub mod ledts0;
#[doc = "SD and Multimediacard Interface"]
pub struct Sdmmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdmmc {}
impl Sdmmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdmmc::RegisterBlock = 0x4801_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdmmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Sdmmc {
    type Target = sdmmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdmmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdmmc").finish()
    }
}
#[doc = "SD and Multimediacard Interface"]
pub mod sdmmc;
#[doc = "External Bus Unit"]
pub struct Ebu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ebu {}
impl Ebu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ebu::RegisterBlock = 0x5800_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ebu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ebu {
    type Target = ebu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ebu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ebu").finish()
    }
}
#[doc = "External Bus Unit"]
pub mod ebu;
#[doc = "Ethernet Control Register"]
pub struct Eth0Con {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eth0Con {}
impl Eth0Con {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eth0_con::RegisterBlock = 0x5000_4040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eth0_con::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eth0Con {
    type Target = eth0_con::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eth0Con {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eth0Con").finish()
    }
}
#[doc = "Ethernet Control Register"]
pub mod eth0_con;
#[doc = "Ethernet Unit 0"]
pub struct Eth0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eth0 {}
impl Eth0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eth0::RegisterBlock = 0x5000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eth0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eth0 {
    type Target = eth0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eth0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eth0").finish()
    }
}
#[doc = "Ethernet Unit 0"]
pub mod eth0;
#[doc = "Universal Serial Bus"]
pub struct Usb0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0 {}
impl Usb0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0::RegisterBlock = 0x5004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0 {
    type Target = usb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep0 {}
impl Usb0Ep0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep0::RegisterBlock = 0x5004_0900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep0 {
    type Target = usb0_ep0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ep0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep1 {}
impl Usb0Ep1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0920 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep1 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep1").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ep1;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep2 {}
impl Usb0Ep2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0940 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep2 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep2").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep2;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep3 {}
impl Usb0Ep3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0960 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep3 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep3").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep3;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep4 {}
impl Usb0Ep4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0980 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep4 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep4").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep4;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep5 {}
impl Usb0Ep5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_09a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep5 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep5").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep5;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep6 {}
impl Usb0Ep6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_09c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep6 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep6").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep6;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch0 {}
impl Usb0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch0 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ch0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch1 {}
impl Usb0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0520 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch1 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch1").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch1;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch2 {}
impl Usb0Ch2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch2 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch2").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch2;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch3 {}
impl Usb0Ch3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0560 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch3 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch3").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch3;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch4 {}
impl Usb0Ch4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch4 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch4").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch4;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch5 {}
impl Usb0Ch5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch5 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch5").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch5;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch6 {}
impl Usb0Ch6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch6 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch6").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch6;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch7 {}
impl Usb0Ch7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch7 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch7").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch7;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch8 {}
impl Usb0Ch8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch8 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch8").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch8;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch9 {}
impl Usb0Ch9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0620 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch9 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch9").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch9;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch10 {}
impl Usb0Ch10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch10 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch10").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch10;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch11 {}
impl Usb0Ch11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0660 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch11 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch11").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch11;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch12 {}
impl Usb0Ch12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch12 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch12").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch12;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch13 {}
impl Usb0Ch13 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_06a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch13 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch13").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch13;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0 {}
impl Usic0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0::RegisterBlock = 0x4003_0008 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0 {
    type Target = usic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub mod usic0;
#[doc = "Universal Serial Interface Controller 1"]
pub struct Usic1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1 {}
impl Usic1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0::RegisterBlock = 0x4802_0008 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1 {
    type Target = usic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 1"]
pub use self::usic0 as usic1;
#[doc = "Universal Serial Interface Controller 2"]
pub struct Usic2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic2 {}
impl Usic2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0::RegisterBlock = 0x4802_4008 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic2 {
    type Target = usic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic2").finish()
    }
}
#[doc = "Universal Serial Interface Controller 2"]
pub use self::usic0 as usic2;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0Ch0 {}
impl Usic0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0Ch0 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0Ch0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub mod usic0_ch0;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0Ch1 {}
impl Usic0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4003_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0Ch1 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0Ch1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic0_ch1;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic1Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1Ch0 {}
impl Usic1Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1Ch0 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1Ch0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic1_ch0;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic1Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1Ch1 {}
impl Usic1Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1Ch1 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1Ch1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic1_ch1;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic2Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic2Ch0 {}
impl Usic2Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic2Ch0 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic2Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic2Ch0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic2_ch0;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic2Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic2Ch1 {}
impl Usic2Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic2Ch1 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic2Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic2Ch1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic2_ch1;
#[doc = "Controller Area Networks"]
pub struct Can {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Can {}
impl Can {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can::RegisterBlock = 0x4801_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Can {
    type Target = can::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Can {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Can").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can;
#[doc = "Controller Area Networks"]
pub struct CanNode0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanNode0 {}
impl CanNode0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_node0::RegisterBlock = 0x4801_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_node0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanNode0 {
    type Target = can_node0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanNode0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanNode0").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can_node0;
#[doc = "Controller Area Networks"]
pub struct CanNode1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanNode1 {}
impl CanNode1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_node0::RegisterBlock = 0x4801_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_node0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanNode1 {
    type Target = can_node0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanNode1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanNode1").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_node0 as can_node1;
#[doc = "Controller Area Networks"]
pub struct CanNode2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanNode2 {}
impl CanNode2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_node0::RegisterBlock = 0x4801_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_node0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanNode2 {
    type Target = can_node0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanNode2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanNode2").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_node0 as can_node2;
#[doc = "Controller Area Networks"]
pub struct CanMo0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo0 {}
impl CanMo0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo0 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo0").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can_mo0;
#[doc = "Controller Area Networks"]
pub struct CanMo1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo1 {}
impl CanMo1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo1 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo1").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo1;
#[doc = "Controller Area Networks"]
pub struct CanMo2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo2 {}
impl CanMo2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo2 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo2").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo2;
#[doc = "Controller Area Networks"]
pub struct CanMo3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo3 {}
impl CanMo3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo3 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo3").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo3;
#[doc = "Controller Area Networks"]
pub struct CanMo4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo4 {}
impl CanMo4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo4 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo4").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo4;
#[doc = "Controller Area Networks"]
pub struct CanMo5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo5 {}
impl CanMo5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_50a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo5 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo5").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo5;
#[doc = "Controller Area Networks"]
pub struct CanMo6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo6 {}
impl CanMo6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_50c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo6 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo6").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo6;
#[doc = "Controller Area Networks"]
pub struct CanMo7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo7 {}
impl CanMo7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_50e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo7 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo7").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo7;
#[doc = "Controller Area Networks"]
pub struct CanMo8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo8 {}
impl CanMo8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo8 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo8").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo8;
#[doc = "Controller Area Networks"]
pub struct CanMo9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo9 {}
impl CanMo9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5120 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo9 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo9").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo9;
#[doc = "Controller Area Networks"]
pub struct CanMo10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo10 {}
impl CanMo10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5140 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo10 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo10").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo10;
#[doc = "Controller Area Networks"]
pub struct CanMo11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo11 {}
impl CanMo11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5160 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo11 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo11").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo11;
#[doc = "Controller Area Networks"]
pub struct CanMo12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo12 {}
impl CanMo12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo12 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo12").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo12;
#[doc = "Controller Area Networks"]
pub struct CanMo13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo13 {}
impl CanMo13 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_51a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo13 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo13").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo13;
#[doc = "Controller Area Networks"]
pub struct CanMo14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo14 {}
impl CanMo14 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_51c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo14 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo14").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo14;
#[doc = "Controller Area Networks"]
pub struct CanMo15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo15 {}
impl CanMo15 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_51e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo15 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo15").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo15;
#[doc = "Controller Area Networks"]
pub struct CanMo16 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo16 {}
impl CanMo16 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo16 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo16").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo16;
#[doc = "Controller Area Networks"]
pub struct CanMo17 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo17 {}
impl CanMo17 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5220 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo17 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo17").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo17;
#[doc = "Controller Area Networks"]
pub struct CanMo18 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo18 {}
impl CanMo18 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5240 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo18 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo18 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo18").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo18;
#[doc = "Controller Area Networks"]
pub struct CanMo19 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo19 {}
impl CanMo19 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5260 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo19 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo19 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo19").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo19;
#[doc = "Controller Area Networks"]
pub struct CanMo20 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo20 {}
impl CanMo20 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5280 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo20 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo20 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo20").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo20;
#[doc = "Controller Area Networks"]
pub struct CanMo21 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo21 {}
impl CanMo21 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_52a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo21 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo21 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo21").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo21;
#[doc = "Controller Area Networks"]
pub struct CanMo22 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo22 {}
impl CanMo22 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_52c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo22 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo22 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo22").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo22;
#[doc = "Controller Area Networks"]
pub struct CanMo23 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo23 {}
impl CanMo23 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_52e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo23 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo23 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo23").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo23;
#[doc = "Controller Area Networks"]
pub struct CanMo24 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo24 {}
impl CanMo24 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo24 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo24 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo24").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo24;
#[doc = "Controller Area Networks"]
pub struct CanMo25 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo25 {}
impl CanMo25 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5320 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo25 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo25 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo25").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo25;
#[doc = "Controller Area Networks"]
pub struct CanMo26 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo26 {}
impl CanMo26 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5340 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo26 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo26 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo26").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo26;
#[doc = "Controller Area Networks"]
pub struct CanMo27 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo27 {}
impl CanMo27 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5360 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo27 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo27 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo27").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo27;
#[doc = "Controller Area Networks"]
pub struct CanMo28 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo28 {}
impl CanMo28 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5380 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo28 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo28 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo28").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo28;
#[doc = "Controller Area Networks"]
pub struct CanMo29 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo29 {}
impl CanMo29 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_53a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo29 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo29 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo29").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo29;
#[doc = "Controller Area Networks"]
pub struct CanMo30 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo30 {}
impl CanMo30 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_53c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo30 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo30 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo30").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo30;
#[doc = "Controller Area Networks"]
pub struct CanMo31 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo31 {}
impl CanMo31 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_53e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo31 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo31 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo31").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo31;
#[doc = "Controller Area Networks"]
pub struct CanMo32 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo32 {}
impl CanMo32 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo32 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo32 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo32").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo32;
#[doc = "Controller Area Networks"]
pub struct CanMo33 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo33 {}
impl CanMo33 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5420 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo33 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo33 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo33").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo33;
#[doc = "Controller Area Networks"]
pub struct CanMo34 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo34 {}
impl CanMo34 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo34 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo34 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo34").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo34;
#[doc = "Controller Area Networks"]
pub struct CanMo35 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo35 {}
impl CanMo35 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5460 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo35 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo35 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo35").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo35;
#[doc = "Controller Area Networks"]
pub struct CanMo36 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo36 {}
impl CanMo36 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo36 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo36 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo36").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo36;
#[doc = "Controller Area Networks"]
pub struct CanMo37 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo37 {}
impl CanMo37 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_54a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo37 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo37 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo37").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo37;
#[doc = "Controller Area Networks"]
pub struct CanMo38 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo38 {}
impl CanMo38 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_54c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo38 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo38 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo38").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo38;
#[doc = "Controller Area Networks"]
pub struct CanMo39 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo39 {}
impl CanMo39 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_54e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo39 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo39 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo39").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo39;
#[doc = "Controller Area Networks"]
pub struct CanMo40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo40 {}
impl CanMo40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo40 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo40").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo40;
#[doc = "Controller Area Networks"]
pub struct CanMo41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo41 {}
impl CanMo41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5520 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo41 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo41").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo41;
#[doc = "Controller Area Networks"]
pub struct CanMo42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo42 {}
impl CanMo42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo42 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo42").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo42;
#[doc = "Controller Area Networks"]
pub struct CanMo43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo43 {}
impl CanMo43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5560 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo43 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo43").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo43;
#[doc = "Controller Area Networks"]
pub struct CanMo44 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo44 {}
impl CanMo44 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo44 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo44 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo44").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo44;
#[doc = "Controller Area Networks"]
pub struct CanMo45 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo45 {}
impl CanMo45 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_55a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo45 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo45 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo45").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo45;
#[doc = "Controller Area Networks"]
pub struct CanMo46 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo46 {}
impl CanMo46 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_55c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo46 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo46 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo46").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo46;
#[doc = "Controller Area Networks"]
pub struct CanMo47 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo47 {}
impl CanMo47 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_55e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo47 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo47 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo47").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo47;
#[doc = "Controller Area Networks"]
pub struct CanMo48 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo48 {}
impl CanMo48 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo48 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo48 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo48").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo48;
#[doc = "Controller Area Networks"]
pub struct CanMo49 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo49 {}
impl CanMo49 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5620 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo49 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo49 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo49").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo49;
#[doc = "Controller Area Networks"]
pub struct CanMo50 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo50 {}
impl CanMo50 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo50 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo50 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo50").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo50;
#[doc = "Controller Area Networks"]
pub struct CanMo51 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo51 {}
impl CanMo51 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5660 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo51 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo51 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo51").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo51;
#[doc = "Controller Area Networks"]
pub struct CanMo52 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo52 {}
impl CanMo52 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo52 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo52 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo52").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo52;
#[doc = "Controller Area Networks"]
pub struct CanMo53 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo53 {}
impl CanMo53 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_56a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo53 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo53 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo53").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo53;
#[doc = "Controller Area Networks"]
pub struct CanMo54 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo54 {}
impl CanMo54 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_56c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo54 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo54 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo54").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo54;
#[doc = "Controller Area Networks"]
pub struct CanMo55 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo55 {}
impl CanMo55 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_56e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo55 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo55 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo55").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo55;
#[doc = "Controller Area Networks"]
pub struct CanMo56 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo56 {}
impl CanMo56 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo56 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo56 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo56").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo56;
#[doc = "Controller Area Networks"]
pub struct CanMo57 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo57 {}
impl CanMo57 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5720 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo57 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo57 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo57").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo57;
#[doc = "Controller Area Networks"]
pub struct CanMo58 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo58 {}
impl CanMo58 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5740 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo58 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo58 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo58").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo58;
#[doc = "Controller Area Networks"]
pub struct CanMo59 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo59 {}
impl CanMo59 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5760 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo59 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo59 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo59").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo59;
#[doc = "Controller Area Networks"]
pub struct CanMo60 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo60 {}
impl CanMo60 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_5780 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo60 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo60 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo60").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo60;
#[doc = "Controller Area Networks"]
pub struct CanMo61 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo61 {}
impl CanMo61 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_57a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo61 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo61 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo61").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo61;
#[doc = "Controller Area Networks"]
pub struct CanMo62 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo62 {}
impl CanMo62 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_57c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo62 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo62 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo62").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo62;
#[doc = "Controller Area Networks"]
pub struct CanMo63 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo63 {}
impl CanMo63 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo0::RegisterBlock = 0x4801_57e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo63 {
    type Target = can_mo0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo63 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo63").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_mo0 as can_mo63;
#[doc = "Analog to Digital Converter"]
pub struct Vadc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vadc {}
impl Vadc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Vadc {
    type Target = vadc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vadc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vadc").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub mod vadc;
#[doc = "Analog to Digital Converter"]
pub struct VadcG0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG0 {}
impl VadcG0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG0 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG0").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub mod vadc_g0;
#[doc = "Analog to Digital Converter"]
pub struct VadcG1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG1 {}
impl VadcG1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG1 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG1").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub use self::vadc_g0 as vadc_g1;
#[doc = "Analog to Digital Converter"]
pub struct VadcG2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG2 {}
impl VadcG2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG2 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG2").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub use self::vadc_g0 as vadc_g2;
#[doc = "Analog to Digital Converter"]
pub struct VadcG3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG3 {}
impl VadcG3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG3 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG3").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub use self::vadc_g0 as vadc_g3;
#[doc = "Delta Sigma Demodulator"]
pub struct Dsd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dsd {}
impl Dsd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsd::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Dsd {
    type Target = dsd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dsd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dsd").finish()
    }
}
#[doc = "Delta Sigma Demodulator"]
pub mod dsd;
#[doc = "Delta Sigma Demodulator"]
pub struct DsdCh0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DsdCh0 {}
impl DsdCh0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsd_ch0::RegisterBlock = 0x4000_8100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsd_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for DsdCh0 {
    type Target = dsd_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DsdCh0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DsdCh0").finish()
    }
}
#[doc = "Delta Sigma Demodulator"]
pub mod dsd_ch0;
#[doc = "Delta Sigma Demodulator"]
pub struct DsdCh1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DsdCh1 {}
impl DsdCh1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsd_ch0::RegisterBlock = 0x4000_8200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsd_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for DsdCh1 {
    type Target = dsd_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DsdCh1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DsdCh1").finish()
    }
}
#[doc = "Delta Sigma Demodulator"]
pub use self::dsd_ch0 as dsd_ch1;
#[doc = "Delta Sigma Demodulator"]
pub struct DsdCh2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DsdCh2 {}
impl DsdCh2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsd_ch0::RegisterBlock = 0x4000_8300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsd_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for DsdCh2 {
    type Target = dsd_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DsdCh2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DsdCh2").finish()
    }
}
#[doc = "Delta Sigma Demodulator"]
pub use self::dsd_ch0 as dsd_ch2;
#[doc = "Delta Sigma Demodulator"]
pub struct DsdCh3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DsdCh3 {}
impl DsdCh3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsd_ch0::RegisterBlock = 0x4000_8400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsd_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for DsdCh3 {
    type Target = dsd_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DsdCh3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DsdCh3").finish()
    }
}
#[doc = "Delta Sigma Demodulator"]
pub use self::dsd_ch0 as dsd_ch3;
#[doc = "Digital to Analog Converter"]
pub struct Dac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dac {}
impl Dac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dac::RegisterBlock = 0x4801_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Dac {
    type Target = dac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dac").finish()
    }
}
#[doc = "Digital to Analog Converter"]
pub mod dac;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40 {}
impl Ccu40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub mod ccu40;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41 {}
impl Ccu41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40 as ccu41;
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub struct Ccu42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu42 {}
impl Ccu42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu42 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub use self::ccu40 as ccu42;
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub struct Ccu43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu43 {}
impl Ccu43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4800_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu43 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub use self::ccu40 as ccu43;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc40 {}
impl Ccu40Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub mod ccu40_cc40;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc41 {}
impl Ccu40Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc41;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc42 {}
impl Ccu40Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc42;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc43 {}
impl Ccu40Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc43;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc40 {}
impl Ccu41Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc40;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc41 {}
impl Ccu41Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc41;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc42 {}
impl Ccu41Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc42;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc43 {}
impl Ccu41Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc43;
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub struct Ccu42Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu42Cc40 {}
impl Ccu42Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu42Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu42Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu42Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub use self::ccu40_cc40 as ccu42_cc40;
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub struct Ccu42Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu42Cc41 {}
impl Ccu42Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu42Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu42Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu42Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub use self::ccu40_cc40 as ccu42_cc41;
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub struct Ccu42Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu42Cc42 {}
impl Ccu42Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu42Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu42Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu42Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub use self::ccu40_cc40 as ccu42_cc42;
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub struct Ccu42Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu42Cc43 {}
impl Ccu42Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu42Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu42Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu42Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 2"]
pub use self::ccu40_cc40 as ccu42_cc43;
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub struct Ccu43Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu43Cc40 {}
impl Ccu43Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4800_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu43Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu43Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu43Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub use self::ccu40_cc40 as ccu43_cc40;
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub struct Ccu43Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu43Cc41 {}
impl Ccu43Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4800_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu43Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu43Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu43Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub use self::ccu40_cc40 as ccu43_cc41;
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub struct Ccu43Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu43Cc42 {}
impl Ccu43Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4800_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu43Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu43Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu43Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub use self::ccu40_cc40 as ccu43_cc42;
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub struct Ccu43Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu43Cc43 {}
impl Ccu43Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4800_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu43Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu43Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu43Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 3"]
pub use self::ccu40_cc40 as ccu43_cc43;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80 {}
impl Ccu80 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80 {
    type Target = ccu80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub mod ccu80;
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub struct Ccu81 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu81 {}
impl Ccu81 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu81 {
    type Target = ccu80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu81 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu81").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub use self::ccu80 as ccu81;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc80 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc80 {}
impl Ccu80Cc80 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc80 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc80 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc80").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub mod ccu80_cc80;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc81 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc81 {}
impl Ccu80Cc81 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc81 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc81 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc81").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc81;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc82 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc82 {}
impl Ccu80Cc82 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc82 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc82 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc82").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc82;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc83 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc83 {}
impl Ccu80Cc83 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc83 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc83 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc83").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc83;
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub struct Ccu81Cc80 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu81Cc80 {}
impl Ccu81Cc80 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu81Cc80 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu81Cc80 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu81Cc80").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub use self::ccu80_cc80 as ccu81_cc80;
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub struct Ccu81Cc81 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu81Cc81 {}
impl Ccu81Cc81 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu81Cc81 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu81Cc81 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu81Cc81").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub use self::ccu80_cc80 as ccu81_cc81;
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub struct Ccu81Cc82 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu81Cc82 {}
impl Ccu81Cc82 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu81Cc82 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu81Cc82 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu81Cc82").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub use self::ccu80_cc80 as ccu81_cc82;
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub struct Ccu81Cc83 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu81Cc83 {}
impl Ccu81Cc83 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu81Cc83 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu81Cc83 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu81Cc83").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 1"]
pub use self::ccu80_cc80 as ccu81_cc83;
#[doc = "Position Interface 0"]
pub struct Posif0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Posif0 {}
impl Posif0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const posif0::RegisterBlock = 0x4002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const posif0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Posif0 {
    type Target = posif0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Posif0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Posif0").finish()
    }
}
#[doc = "Position Interface 0"]
pub mod posif0;
#[doc = "Position Interface 1"]
pub struct Posif1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Posif1 {}
impl Posif1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const posif0::RegisterBlock = 0x4002_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const posif0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Posif1 {
    type Target = posif0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Posif1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Posif1").finish()
    }
}
#[doc = "Position Interface 1"]
pub use self::posif0 as posif1;
#[doc = "Port 0"]
pub struct Port0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port0 {}
impl Port0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port0::RegisterBlock = 0x4802_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port0 {
    type Target = port0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port0").finish()
    }
}
#[doc = "Port 0"]
pub mod port0;
#[doc = "Port 1"]
pub struct Port1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port1 {}
impl Port1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port1::RegisterBlock = 0x4802_8100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port1 {
    type Target = port1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port1").finish()
    }
}
#[doc = "Port 1"]
pub mod port1;
#[doc = "Port 2"]
pub struct Port2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port2 {}
impl Port2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port2::RegisterBlock = 0x4802_8200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port2 {
    type Target = port2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port2").finish()
    }
}
#[doc = "Port 2"]
pub mod port2;
#[doc = "Port 3"]
pub struct Port3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port3 {}
impl Port3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port3::RegisterBlock = 0x4802_8300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port3 {
    type Target = port3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port3").finish()
    }
}
#[doc = "Port 3"]
pub mod port3;
#[doc = "Port 4"]
pub struct Port4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port4 {}
impl Port4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port4::RegisterBlock = 0x4802_8400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port4 {
    type Target = port4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port4").finish()
    }
}
#[doc = "Port 4"]
pub mod port4;
#[doc = "Port 5"]
pub struct Port5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port5 {}
impl Port5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port5::RegisterBlock = 0x4802_8500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port5::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port5 {
    type Target = port5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port5").finish()
    }
}
#[doc = "Port 5"]
pub mod port5;
#[doc = "Port 6"]
pub struct Port6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port6 {}
impl Port6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port6::RegisterBlock = 0x4802_8600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port6::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port6 {
    type Target = port6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port6").finish()
    }
}
#[doc = "Port 6"]
pub mod port6;
#[doc = "Port 14"]
pub struct Port14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port14 {}
impl Port14 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port14::RegisterBlock = 0x4802_8e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port14::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port14 {
    type Target = port14::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port14").finish()
    }
}
#[doc = "Port 14"]
pub mod port14;
#[doc = "Port 15"]
pub struct Port15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port15 {}
impl Port15 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port15::RegisterBlock = 0x4802_8f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port15::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port15 {
    type Target = port15::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port15").finish()
    }
}
#[doc = "Port 15"]
pub mod port15;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PPB"]
    pub ppb: Ppb,
    #[doc = "DLR"]
    pub dlr: Dlr,
    #[doc = "ERU0"]
    pub eru0: Eru0,
    #[doc = "ERU1"]
    pub eru1: Eru1,
    #[doc = "GPDMA0"]
    pub gpdma0: Gpdma0,
    #[doc = "GPDMA0_CH0"]
    pub gpdma0_ch0: Gpdma0Ch0,
    #[doc = "GPDMA0_CH1"]
    pub gpdma0_ch1: Gpdma0Ch1,
    #[doc = "GPDMA0_CH2"]
    pub gpdma0_ch2: Gpdma0Ch2,
    #[doc = "GPDMA0_CH3"]
    pub gpdma0_ch3: Gpdma0Ch3,
    #[doc = "GPDMA0_CH4"]
    pub gpdma0_ch4: Gpdma0Ch4,
    #[doc = "GPDMA0_CH5"]
    pub gpdma0_ch5: Gpdma0Ch5,
    #[doc = "GPDMA0_CH6"]
    pub gpdma0_ch6: Gpdma0Ch6,
    #[doc = "GPDMA0_CH7"]
    pub gpdma0_ch7: Gpdma0Ch7,
    #[doc = "GPDMA1"]
    pub gpdma1: Gpdma1,
    #[doc = "GPDMA1_CH0"]
    pub gpdma1_ch0: Gpdma1Ch0,
    #[doc = "GPDMA1_CH1"]
    pub gpdma1_ch1: Gpdma1Ch1,
    #[doc = "GPDMA1_CH2"]
    pub gpdma1_ch2: Gpdma1Ch2,
    #[doc = "GPDMA1_CH3"]
    pub gpdma1_ch3: Gpdma1Ch3,
    #[doc = "FCE"]
    pub fce: Fce,
    #[doc = "FCE_KE0"]
    pub fce_ke0: FceKe0,
    #[doc = "FCE_KE1"]
    pub fce_ke1: FceKe1,
    #[doc = "FCE_KE2"]
    pub fce_ke2: FceKe2,
    #[doc = "FCE_KE3"]
    pub fce_ke3: FceKe3,
    #[doc = "PBA0"]
    pub pba0: Pba0,
    #[doc = "PBA1"]
    pub pba1: Pba1,
    #[doc = "FLASH0"]
    pub flash0: Flash0,
    #[doc = "PREF"]
    pub pref: Pref,
    #[doc = "PMU0"]
    pub pmu0: Pmu0,
    #[doc = "WDT"]
    pub wdt: Wdt,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "SCU_CLK"]
    pub scu_clk: ScuClk,
    #[doc = "SCU_OSC"]
    pub scu_osc: ScuOsc,
    #[doc = "SCU_PLL"]
    pub scu_pll: ScuPll,
    #[doc = "SCU_GENERAL"]
    pub scu_general: ScuGeneral,
    #[doc = "SCU_INTERRUPT"]
    pub scu_interrupt: ScuInterrupt,
    #[doc = "SCU_PARITY"]
    pub scu_parity: ScuParity,
    #[doc = "SCU_TRAP"]
    pub scu_trap: ScuTrap,
    #[doc = "SCU_HIBERNATE"]
    pub scu_hibernate: ScuHibernate,
    #[doc = "SCU_POWER"]
    pub scu_power: ScuPower,
    #[doc = "SCU_RESET"]
    pub scu_reset: ScuReset,
    #[doc = "LEDTS0"]
    pub ledts0: Ledts0,
    #[doc = "SDMMC"]
    pub sdmmc: Sdmmc,
    #[doc = "EBU"]
    pub ebu: Ebu,
    #[doc = "ETH0_CON"]
    pub eth0_con: Eth0Con,
    #[doc = "ETH0"]
    pub eth0: Eth0,
    #[doc = "USB0"]
    pub usb0: Usb0,
    #[doc = "USB0_EP0"]
    pub usb0_ep0: Usb0Ep0,
    #[doc = "USB0_EP1"]
    pub usb0_ep1: Usb0Ep1,
    #[doc = "USB0_EP2"]
    pub usb0_ep2: Usb0Ep2,
    #[doc = "USB0_EP3"]
    pub usb0_ep3: Usb0Ep3,
    #[doc = "USB0_EP4"]
    pub usb0_ep4: Usb0Ep4,
    #[doc = "USB0_EP5"]
    pub usb0_ep5: Usb0Ep5,
    #[doc = "USB0_EP6"]
    pub usb0_ep6: Usb0Ep6,
    #[doc = "USB0_CH0"]
    pub usb0_ch0: Usb0Ch0,
    #[doc = "USB0_CH1"]
    pub usb0_ch1: Usb0Ch1,
    #[doc = "USB0_CH2"]
    pub usb0_ch2: Usb0Ch2,
    #[doc = "USB0_CH3"]
    pub usb0_ch3: Usb0Ch3,
    #[doc = "USB0_CH4"]
    pub usb0_ch4: Usb0Ch4,
    #[doc = "USB0_CH5"]
    pub usb0_ch5: Usb0Ch5,
    #[doc = "USB0_CH6"]
    pub usb0_ch6: Usb0Ch6,
    #[doc = "USB0_CH7"]
    pub usb0_ch7: Usb0Ch7,
    #[doc = "USB0_CH8"]
    pub usb0_ch8: Usb0Ch8,
    #[doc = "USB0_CH9"]
    pub usb0_ch9: Usb0Ch9,
    #[doc = "USB0_CH10"]
    pub usb0_ch10: Usb0Ch10,
    #[doc = "USB0_CH11"]
    pub usb0_ch11: Usb0Ch11,
    #[doc = "USB0_CH12"]
    pub usb0_ch12: Usb0Ch12,
    #[doc = "USB0_CH13"]
    pub usb0_ch13: Usb0Ch13,
    #[doc = "USIC0"]
    pub usic0: Usic0,
    #[doc = "USIC1"]
    pub usic1: Usic1,
    #[doc = "USIC2"]
    pub usic2: Usic2,
    #[doc = "USIC0_CH0"]
    pub usic0_ch0: Usic0Ch0,
    #[doc = "USIC0_CH1"]
    pub usic0_ch1: Usic0Ch1,
    #[doc = "USIC1_CH0"]
    pub usic1_ch0: Usic1Ch0,
    #[doc = "USIC1_CH1"]
    pub usic1_ch1: Usic1Ch1,
    #[doc = "USIC2_CH0"]
    pub usic2_ch0: Usic2Ch0,
    #[doc = "USIC2_CH1"]
    pub usic2_ch1: Usic2Ch1,
    #[doc = "CAN"]
    pub can: Can,
    #[doc = "CAN_NODE0"]
    pub can_node0: CanNode0,
    #[doc = "CAN_NODE1"]
    pub can_node1: CanNode1,
    #[doc = "CAN_NODE2"]
    pub can_node2: CanNode2,
    #[doc = "CAN_MO0"]
    pub can_mo0: CanMo0,
    #[doc = "CAN_MO1"]
    pub can_mo1: CanMo1,
    #[doc = "CAN_MO2"]
    pub can_mo2: CanMo2,
    #[doc = "CAN_MO3"]
    pub can_mo3: CanMo3,
    #[doc = "CAN_MO4"]
    pub can_mo4: CanMo4,
    #[doc = "CAN_MO5"]
    pub can_mo5: CanMo5,
    #[doc = "CAN_MO6"]
    pub can_mo6: CanMo6,
    #[doc = "CAN_MO7"]
    pub can_mo7: CanMo7,
    #[doc = "CAN_MO8"]
    pub can_mo8: CanMo8,
    #[doc = "CAN_MO9"]
    pub can_mo9: CanMo9,
    #[doc = "CAN_MO10"]
    pub can_mo10: CanMo10,
    #[doc = "CAN_MO11"]
    pub can_mo11: CanMo11,
    #[doc = "CAN_MO12"]
    pub can_mo12: CanMo12,
    #[doc = "CAN_MO13"]
    pub can_mo13: CanMo13,
    #[doc = "CAN_MO14"]
    pub can_mo14: CanMo14,
    #[doc = "CAN_MO15"]
    pub can_mo15: CanMo15,
    #[doc = "CAN_MO16"]
    pub can_mo16: CanMo16,
    #[doc = "CAN_MO17"]
    pub can_mo17: CanMo17,
    #[doc = "CAN_MO18"]
    pub can_mo18: CanMo18,
    #[doc = "CAN_MO19"]
    pub can_mo19: CanMo19,
    #[doc = "CAN_MO20"]
    pub can_mo20: CanMo20,
    #[doc = "CAN_MO21"]
    pub can_mo21: CanMo21,
    #[doc = "CAN_MO22"]
    pub can_mo22: CanMo22,
    #[doc = "CAN_MO23"]
    pub can_mo23: CanMo23,
    #[doc = "CAN_MO24"]
    pub can_mo24: CanMo24,
    #[doc = "CAN_MO25"]
    pub can_mo25: CanMo25,
    #[doc = "CAN_MO26"]
    pub can_mo26: CanMo26,
    #[doc = "CAN_MO27"]
    pub can_mo27: CanMo27,
    #[doc = "CAN_MO28"]
    pub can_mo28: CanMo28,
    #[doc = "CAN_MO29"]
    pub can_mo29: CanMo29,
    #[doc = "CAN_MO30"]
    pub can_mo30: CanMo30,
    #[doc = "CAN_MO31"]
    pub can_mo31: CanMo31,
    #[doc = "CAN_MO32"]
    pub can_mo32: CanMo32,
    #[doc = "CAN_MO33"]
    pub can_mo33: CanMo33,
    #[doc = "CAN_MO34"]
    pub can_mo34: CanMo34,
    #[doc = "CAN_MO35"]
    pub can_mo35: CanMo35,
    #[doc = "CAN_MO36"]
    pub can_mo36: CanMo36,
    #[doc = "CAN_MO37"]
    pub can_mo37: CanMo37,
    #[doc = "CAN_MO38"]
    pub can_mo38: CanMo38,
    #[doc = "CAN_MO39"]
    pub can_mo39: CanMo39,
    #[doc = "CAN_MO40"]
    pub can_mo40: CanMo40,
    #[doc = "CAN_MO41"]
    pub can_mo41: CanMo41,
    #[doc = "CAN_MO42"]
    pub can_mo42: CanMo42,
    #[doc = "CAN_MO43"]
    pub can_mo43: CanMo43,
    #[doc = "CAN_MO44"]
    pub can_mo44: CanMo44,
    #[doc = "CAN_MO45"]
    pub can_mo45: CanMo45,
    #[doc = "CAN_MO46"]
    pub can_mo46: CanMo46,
    #[doc = "CAN_MO47"]
    pub can_mo47: CanMo47,
    #[doc = "CAN_MO48"]
    pub can_mo48: CanMo48,
    #[doc = "CAN_MO49"]
    pub can_mo49: CanMo49,
    #[doc = "CAN_MO50"]
    pub can_mo50: CanMo50,
    #[doc = "CAN_MO51"]
    pub can_mo51: CanMo51,
    #[doc = "CAN_MO52"]
    pub can_mo52: CanMo52,
    #[doc = "CAN_MO53"]
    pub can_mo53: CanMo53,
    #[doc = "CAN_MO54"]
    pub can_mo54: CanMo54,
    #[doc = "CAN_MO55"]
    pub can_mo55: CanMo55,
    #[doc = "CAN_MO56"]
    pub can_mo56: CanMo56,
    #[doc = "CAN_MO57"]
    pub can_mo57: CanMo57,
    #[doc = "CAN_MO58"]
    pub can_mo58: CanMo58,
    #[doc = "CAN_MO59"]
    pub can_mo59: CanMo59,
    #[doc = "CAN_MO60"]
    pub can_mo60: CanMo60,
    #[doc = "CAN_MO61"]
    pub can_mo61: CanMo61,
    #[doc = "CAN_MO62"]
    pub can_mo62: CanMo62,
    #[doc = "CAN_MO63"]
    pub can_mo63: CanMo63,
    #[doc = "VADC"]
    pub vadc: Vadc,
    #[doc = "VADC_G0"]
    pub vadc_g0: VadcG0,
    #[doc = "VADC_G1"]
    pub vadc_g1: VadcG1,
    #[doc = "VADC_G2"]
    pub vadc_g2: VadcG2,
    #[doc = "VADC_G3"]
    pub vadc_g3: VadcG3,
    #[doc = "DSD"]
    pub dsd: Dsd,
    #[doc = "DSD_CH0"]
    pub dsd_ch0: DsdCh0,
    #[doc = "DSD_CH1"]
    pub dsd_ch1: DsdCh1,
    #[doc = "DSD_CH2"]
    pub dsd_ch2: DsdCh2,
    #[doc = "DSD_CH3"]
    pub dsd_ch3: DsdCh3,
    #[doc = "DAC"]
    pub dac: Dac,
    #[doc = "CCU40"]
    pub ccu40: Ccu40,
    #[doc = "CCU41"]
    pub ccu41: Ccu41,
    #[doc = "CCU42"]
    pub ccu42: Ccu42,
    #[doc = "CCU43"]
    pub ccu43: Ccu43,
    #[doc = "CCU40_CC40"]
    pub ccu40_cc40: Ccu40Cc40,
    #[doc = "CCU40_CC41"]
    pub ccu40_cc41: Ccu40Cc41,
    #[doc = "CCU40_CC42"]
    pub ccu40_cc42: Ccu40Cc42,
    #[doc = "CCU40_CC43"]
    pub ccu40_cc43: Ccu40Cc43,
    #[doc = "CCU41_CC40"]
    pub ccu41_cc40: Ccu41Cc40,
    #[doc = "CCU41_CC41"]
    pub ccu41_cc41: Ccu41Cc41,
    #[doc = "CCU41_CC42"]
    pub ccu41_cc42: Ccu41Cc42,
    #[doc = "CCU41_CC43"]
    pub ccu41_cc43: Ccu41Cc43,
    #[doc = "CCU42_CC40"]
    pub ccu42_cc40: Ccu42Cc40,
    #[doc = "CCU42_CC41"]
    pub ccu42_cc41: Ccu42Cc41,
    #[doc = "CCU42_CC42"]
    pub ccu42_cc42: Ccu42Cc42,
    #[doc = "CCU42_CC43"]
    pub ccu42_cc43: Ccu42Cc43,
    #[doc = "CCU43_CC40"]
    pub ccu43_cc40: Ccu43Cc40,
    #[doc = "CCU43_CC41"]
    pub ccu43_cc41: Ccu43Cc41,
    #[doc = "CCU43_CC42"]
    pub ccu43_cc42: Ccu43Cc42,
    #[doc = "CCU43_CC43"]
    pub ccu43_cc43: Ccu43Cc43,
    #[doc = "CCU80"]
    pub ccu80: Ccu80,
    #[doc = "CCU81"]
    pub ccu81: Ccu81,
    #[doc = "CCU80_CC80"]
    pub ccu80_cc80: Ccu80Cc80,
    #[doc = "CCU80_CC81"]
    pub ccu80_cc81: Ccu80Cc81,
    #[doc = "CCU80_CC82"]
    pub ccu80_cc82: Ccu80Cc82,
    #[doc = "CCU80_CC83"]
    pub ccu80_cc83: Ccu80Cc83,
    #[doc = "CCU81_CC80"]
    pub ccu81_cc80: Ccu81Cc80,
    #[doc = "CCU81_CC81"]
    pub ccu81_cc81: Ccu81Cc81,
    #[doc = "CCU81_CC82"]
    pub ccu81_cc82: Ccu81Cc82,
    #[doc = "CCU81_CC83"]
    pub ccu81_cc83: Ccu81Cc83,
    #[doc = "POSIF0"]
    pub posif0: Posif0,
    #[doc = "POSIF1"]
    pub posif1: Posif1,
    #[doc = "PORT0"]
    pub port0: Port0,
    #[doc = "PORT1"]
    pub port1: Port1,
    #[doc = "PORT2"]
    pub port2: Port2,
    #[doc = "PORT3"]
    pub port3: Port3,
    #[doc = "PORT4"]
    pub port4: Port4,
    #[doc = "PORT5"]
    pub port5: Port5,
    #[doc = "PORT6"]
    pub port6: Port6,
    #[doc = "PORT14"]
    pub port14: Port14,
    #[doc = "PORT15"]
    pub port15: Port15,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ppb: Ppb { _marker: PhantomData },
            dlr: Dlr { _marker: PhantomData },
            eru0: Eru0 { _marker: PhantomData },
            eru1: Eru1 { _marker: PhantomData },
            gpdma0: Gpdma0 { _marker: PhantomData },
            gpdma0_ch0: Gpdma0Ch0 { _marker: PhantomData },
            gpdma0_ch1: Gpdma0Ch1 { _marker: PhantomData },
            gpdma0_ch2: Gpdma0Ch2 { _marker: PhantomData },
            gpdma0_ch3: Gpdma0Ch3 { _marker: PhantomData },
            gpdma0_ch4: Gpdma0Ch4 { _marker: PhantomData },
            gpdma0_ch5: Gpdma0Ch5 { _marker: PhantomData },
            gpdma0_ch6: Gpdma0Ch6 { _marker: PhantomData },
            gpdma0_ch7: Gpdma0Ch7 { _marker: PhantomData },
            gpdma1: Gpdma1 { _marker: PhantomData },
            gpdma1_ch0: Gpdma1Ch0 { _marker: PhantomData },
            gpdma1_ch1: Gpdma1Ch1 { _marker: PhantomData },
            gpdma1_ch2: Gpdma1Ch2 { _marker: PhantomData },
            gpdma1_ch3: Gpdma1Ch3 { _marker: PhantomData },
            fce: Fce { _marker: PhantomData },
            fce_ke0: FceKe0 { _marker: PhantomData },
            fce_ke1: FceKe1 { _marker: PhantomData },
            fce_ke2: FceKe2 { _marker: PhantomData },
            fce_ke3: FceKe3 { _marker: PhantomData },
            pba0: Pba0 { _marker: PhantomData },
            pba1: Pba1 { _marker: PhantomData },
            flash0: Flash0 { _marker: PhantomData },
            pref: Pref { _marker: PhantomData },
            pmu0: Pmu0 { _marker: PhantomData },
            wdt: Wdt { _marker: PhantomData },
            rtc: Rtc { _marker: PhantomData },
            scu_clk: ScuClk { _marker: PhantomData },
            scu_osc: ScuOsc { _marker: PhantomData },
            scu_pll: ScuPll { _marker: PhantomData },
            scu_general: ScuGeneral { _marker: PhantomData },
            scu_interrupt: ScuInterrupt { _marker: PhantomData },
            scu_parity: ScuParity { _marker: PhantomData },
            scu_trap: ScuTrap { _marker: PhantomData },
            scu_hibernate: ScuHibernate { _marker: PhantomData },
            scu_power: ScuPower { _marker: PhantomData },
            scu_reset: ScuReset { _marker: PhantomData },
            ledts0: Ledts0 { _marker: PhantomData },
            sdmmc: Sdmmc { _marker: PhantomData },
            ebu: Ebu { _marker: PhantomData },
            eth0_con: Eth0Con { _marker: PhantomData },
            eth0: Eth0 { _marker: PhantomData },
            usb0: Usb0 { _marker: PhantomData },
            usb0_ep0: Usb0Ep0 { _marker: PhantomData },
            usb0_ep1: Usb0Ep1 { _marker: PhantomData },
            usb0_ep2: Usb0Ep2 { _marker: PhantomData },
            usb0_ep3: Usb0Ep3 { _marker: PhantomData },
            usb0_ep4: Usb0Ep4 { _marker: PhantomData },
            usb0_ep5: Usb0Ep5 { _marker: PhantomData },
            usb0_ep6: Usb0Ep6 { _marker: PhantomData },
            usb0_ch0: Usb0Ch0 { _marker: PhantomData },
            usb0_ch1: Usb0Ch1 { _marker: PhantomData },
            usb0_ch2: Usb0Ch2 { _marker: PhantomData },
            usb0_ch3: Usb0Ch3 { _marker: PhantomData },
            usb0_ch4: Usb0Ch4 { _marker: PhantomData },
            usb0_ch5: Usb0Ch5 { _marker: PhantomData },
            usb0_ch6: Usb0Ch6 { _marker: PhantomData },
            usb0_ch7: Usb0Ch7 { _marker: PhantomData },
            usb0_ch8: Usb0Ch8 { _marker: PhantomData },
            usb0_ch9: Usb0Ch9 { _marker: PhantomData },
            usb0_ch10: Usb0Ch10 { _marker: PhantomData },
            usb0_ch11: Usb0Ch11 { _marker: PhantomData },
            usb0_ch12: Usb0Ch12 { _marker: PhantomData },
            usb0_ch13: Usb0Ch13 { _marker: PhantomData },
            usic0: Usic0 { _marker: PhantomData },
            usic1: Usic1 { _marker: PhantomData },
            usic2: Usic2 { _marker: PhantomData },
            usic0_ch0: Usic0Ch0 { _marker: PhantomData },
            usic0_ch1: Usic0Ch1 { _marker: PhantomData },
            usic1_ch0: Usic1Ch0 { _marker: PhantomData },
            usic1_ch1: Usic1Ch1 { _marker: PhantomData },
            usic2_ch0: Usic2Ch0 { _marker: PhantomData },
            usic2_ch1: Usic2Ch1 { _marker: PhantomData },
            can: Can { _marker: PhantomData },
            can_node0: CanNode0 { _marker: PhantomData },
            can_node1: CanNode1 { _marker: PhantomData },
            can_node2: CanNode2 { _marker: PhantomData },
            can_mo0: CanMo0 { _marker: PhantomData },
            can_mo1: CanMo1 { _marker: PhantomData },
            can_mo2: CanMo2 { _marker: PhantomData },
            can_mo3: CanMo3 { _marker: PhantomData },
            can_mo4: CanMo4 { _marker: PhantomData },
            can_mo5: CanMo5 { _marker: PhantomData },
            can_mo6: CanMo6 { _marker: PhantomData },
            can_mo7: CanMo7 { _marker: PhantomData },
            can_mo8: CanMo8 { _marker: PhantomData },
            can_mo9: CanMo9 { _marker: PhantomData },
            can_mo10: CanMo10 { _marker: PhantomData },
            can_mo11: CanMo11 { _marker: PhantomData },
            can_mo12: CanMo12 { _marker: PhantomData },
            can_mo13: CanMo13 { _marker: PhantomData },
            can_mo14: CanMo14 { _marker: PhantomData },
            can_mo15: CanMo15 { _marker: PhantomData },
            can_mo16: CanMo16 { _marker: PhantomData },
            can_mo17: CanMo17 { _marker: PhantomData },
            can_mo18: CanMo18 { _marker: PhantomData },
            can_mo19: CanMo19 { _marker: PhantomData },
            can_mo20: CanMo20 { _marker: PhantomData },
            can_mo21: CanMo21 { _marker: PhantomData },
            can_mo22: CanMo22 { _marker: PhantomData },
            can_mo23: CanMo23 { _marker: PhantomData },
            can_mo24: CanMo24 { _marker: PhantomData },
            can_mo25: CanMo25 { _marker: PhantomData },
            can_mo26: CanMo26 { _marker: PhantomData },
            can_mo27: CanMo27 { _marker: PhantomData },
            can_mo28: CanMo28 { _marker: PhantomData },
            can_mo29: CanMo29 { _marker: PhantomData },
            can_mo30: CanMo30 { _marker: PhantomData },
            can_mo31: CanMo31 { _marker: PhantomData },
            can_mo32: CanMo32 { _marker: PhantomData },
            can_mo33: CanMo33 { _marker: PhantomData },
            can_mo34: CanMo34 { _marker: PhantomData },
            can_mo35: CanMo35 { _marker: PhantomData },
            can_mo36: CanMo36 { _marker: PhantomData },
            can_mo37: CanMo37 { _marker: PhantomData },
            can_mo38: CanMo38 { _marker: PhantomData },
            can_mo39: CanMo39 { _marker: PhantomData },
            can_mo40: CanMo40 { _marker: PhantomData },
            can_mo41: CanMo41 { _marker: PhantomData },
            can_mo42: CanMo42 { _marker: PhantomData },
            can_mo43: CanMo43 { _marker: PhantomData },
            can_mo44: CanMo44 { _marker: PhantomData },
            can_mo45: CanMo45 { _marker: PhantomData },
            can_mo46: CanMo46 { _marker: PhantomData },
            can_mo47: CanMo47 { _marker: PhantomData },
            can_mo48: CanMo48 { _marker: PhantomData },
            can_mo49: CanMo49 { _marker: PhantomData },
            can_mo50: CanMo50 { _marker: PhantomData },
            can_mo51: CanMo51 { _marker: PhantomData },
            can_mo52: CanMo52 { _marker: PhantomData },
            can_mo53: CanMo53 { _marker: PhantomData },
            can_mo54: CanMo54 { _marker: PhantomData },
            can_mo55: CanMo55 { _marker: PhantomData },
            can_mo56: CanMo56 { _marker: PhantomData },
            can_mo57: CanMo57 { _marker: PhantomData },
            can_mo58: CanMo58 { _marker: PhantomData },
            can_mo59: CanMo59 { _marker: PhantomData },
            can_mo60: CanMo60 { _marker: PhantomData },
            can_mo61: CanMo61 { _marker: PhantomData },
            can_mo62: CanMo62 { _marker: PhantomData },
            can_mo63: CanMo63 { _marker: PhantomData },
            vadc: Vadc { _marker: PhantomData },
            vadc_g0: VadcG0 { _marker: PhantomData },
            vadc_g1: VadcG1 { _marker: PhantomData },
            vadc_g2: VadcG2 { _marker: PhantomData },
            vadc_g3: VadcG3 { _marker: PhantomData },
            dsd: Dsd { _marker: PhantomData },
            dsd_ch0: DsdCh0 { _marker: PhantomData },
            dsd_ch1: DsdCh1 { _marker: PhantomData },
            dsd_ch2: DsdCh2 { _marker: PhantomData },
            dsd_ch3: DsdCh3 { _marker: PhantomData },
            dac: Dac { _marker: PhantomData },
            ccu40: Ccu40 { _marker: PhantomData },
            ccu41: Ccu41 { _marker: PhantomData },
            ccu42: Ccu42 { _marker: PhantomData },
            ccu43: Ccu43 { _marker: PhantomData },
            ccu40_cc40: Ccu40Cc40 { _marker: PhantomData },
            ccu40_cc41: Ccu40Cc41 { _marker: PhantomData },
            ccu40_cc42: Ccu40Cc42 { _marker: PhantomData },
            ccu40_cc43: Ccu40Cc43 { _marker: PhantomData },
            ccu41_cc40: Ccu41Cc40 { _marker: PhantomData },
            ccu41_cc41: Ccu41Cc41 { _marker: PhantomData },
            ccu41_cc42: Ccu41Cc42 { _marker: PhantomData },
            ccu41_cc43: Ccu41Cc43 { _marker: PhantomData },
            ccu42_cc40: Ccu42Cc40 { _marker: PhantomData },
            ccu42_cc41: Ccu42Cc41 { _marker: PhantomData },
            ccu42_cc42: Ccu42Cc42 { _marker: PhantomData },
            ccu42_cc43: Ccu42Cc43 { _marker: PhantomData },
            ccu43_cc40: Ccu43Cc40 { _marker: PhantomData },
            ccu43_cc41: Ccu43Cc41 { _marker: PhantomData },
            ccu43_cc42: Ccu43Cc42 { _marker: PhantomData },
            ccu43_cc43: Ccu43Cc43 { _marker: PhantomData },
            ccu80: Ccu80 { _marker: PhantomData },
            ccu81: Ccu81 { _marker: PhantomData },
            ccu80_cc80: Ccu80Cc80 { _marker: PhantomData },
            ccu80_cc81: Ccu80Cc81 { _marker: PhantomData },
            ccu80_cc82: Ccu80Cc82 { _marker: PhantomData },
            ccu80_cc83: Ccu80Cc83 { _marker: PhantomData },
            ccu81_cc80: Ccu81Cc80 { _marker: PhantomData },
            ccu81_cc81: Ccu81Cc81 { _marker: PhantomData },
            ccu81_cc82: Ccu81Cc82 { _marker: PhantomData },
            ccu81_cc83: Ccu81Cc83 { _marker: PhantomData },
            posif0: Posif0 { _marker: PhantomData },
            posif1: Posif1 { _marker: PhantomData },
            port0: Port0 { _marker: PhantomData },
            port1: Port1 { _marker: PhantomData },
            port2: Port2 { _marker: PhantomData },
            port3: Port3 { _marker: PhantomData },
            port4: Port4 { _marker: PhantomData },
            port5: Port5 { _marker: PhantomData },
            port6: Port6 { _marker: PhantomData },
            port14: Port14 { _marker: PhantomData },
            port15: Port15 { _marker: PhantomData },
        }
    }
}
